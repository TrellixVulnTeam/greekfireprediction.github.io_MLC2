# -*- coding: utf-8 -*-
"""neural_network.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WoVwWMZYPCKKfuTZdq5wf3orw_1RvXmj
"""

import pandas as pd
from sklearn.model_selection import train_test_split

from google.colab import drive
#drive.mount('/content/drive')
drive.mount("/content/drive", force_remount=True)

data = pd.read_pickle('drive/MyDrive/Colab Notebooks/working_balanced_df.pkl')

data['FOREST_AREA'] = data['FOREST_AREA'].apply(lambda x: 1 if x >= 0 else 0)  # 1 = fire | 0 = Not fire

data['FOREST_AREA'].value_counts()  # The balanced dataset

working_data = data.to_numpy()

x = data[['TEMPERATURE', 'SPEED', 'DEW']]
y = data['FOREST_AREA']

x = x.to_numpy()
y = y.to_numpy()

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=0)

import keras
from keras.models import Sequential
from keras.layers import Dense, Flatten

clf = Sequential()

# Adding the input layer and the first hidden layer
clf.add(Flatten(input_shape=(3,)))

# Adding the hidden layers
clf.add(Dense(units = 16, activation = 'relu'))
clf.add(Dense(units = 16, activation = 'relu'))
clf.add(Dense(units = 8, activation = 'relu'))

# Adding the output layer

# Probability for the outcome 
clf.add(Dense(units = 1, activation = 'sigmoid'))

# Compiling the ANN
'''Classification'''
#Another Option: categorical_crossentropy
clf.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])

clf.fit(x_train, y_train, batch_size=32, epochs=5)

predictions = clf.predict(x_test)

clf.predict([[21, 1.1, 12]])

x_test[:10]

predictions[:10]

clf.save("nn_model_1.h5")

clf.predict([[30, 5, 10]])

predictions[:10]

y_pred_bool = (y_pred > 0.5)

risk_levels = {
    'very_low': 0.10,
    'low': 0.30,
    'medium': 0.40,
    'high': 0.60,
    'very_high': 0.70
}

very_low = 0
low = 0
medium = 0
high = 0
very_high = 0

probs = predictions.tolist()

probs[:5]

for x in probs:
    #print(x)
    if x[0] <= risk_levels.get('very_low'):
        very_low += 1
    elif x[0] <= risk_levels.get('low'):
        low += 1
    elif x[0] <= risk_levels.get('medium'):
        medium += 1
    elif x[0] <= risk_levels.get('high'):
        high += 1
    else:
        very_high += 1

all = very_low + low + medium + high + very_high

p_very_low = round(very_low/all*100, 2)
p_low = round(low/all*100, 2)
p_medium = round(medium/all*100, 2)
p_high = round(high/all*100, 2)
p_very_high = round(very_high/all*100, 2)

print(f"Very Low: {p_very_low} %")
print(f"Low: {p_low} %")
print(f"Medium: {p_medium} %")
print(f"High: {p_high} %")
print(f"Very High: {p_very_high} %")